#include "Ass-02-Debug.h"

void Debug_Init(void) {
  // Initialise
  info.debug = 0;
  info.system = 0;
  info.formula_mode = 0;
  info.first_time = 1;
  info.graph_mode = 0;
  info.angle_mode = 1;
}
int Get_Debug(void) { return (info.debug); }

int Get_System(void) { return (info.system); }

int Get_Formula_Mode(void) { return (info.formula_mode); }

int Get_First_Time(void) { return (info.first_time); }

int Get_Graph_Mode(void) { return (info.graph_mode); }

int Get_Angle_Mode(void) { return (info.angle_mode); }

void Set_Angle_Mode(int Value) { info.angle_mode = Value; }

void Set_Debug(int Value) { info.debug = Value; }

void Set_System(int Value) { info.system = Value; }

void Set_Formula_Mode(int Value) { info.formula_mode = Value; }

void Set_First_Time(int Value) { info.first_time = Value; }

void Set_Graph_Mode(int Value) { info.graph_mode = Value; }
#include "Ass-02-Equation.h"

void Equation_Init(void) {
  output.prev_ans = 120.04;
  output.result = 24507.064;
  output.pos = 0;
}

int Get_Size(void) { return (equation.size); }

char **Get_Input(void) { return (equation.input); }

char *Get_Input_Str(int position) { return (equation.input[position]); }

int Get_Pos(void) { return (equation.pos); }

void Set_Size(int Value) { equation.size = Value; }

void Set_Input(char **Value) { equation.input = Value; }

void Set_Input_Str(int position, char *Value) {
  equation.input[position] = Value;
}

void Set_Pos(int Value) { equation.pos = Value; }

void Free_Input_Str(int position) { free(equation.input[position]); }

char Get_Formula_c(void) { return (output.formula[output.pos]); }

char Get_Formula_c_pos(int position) { return (output.formula[position]); }

char *Get_Formula(void) { return (output.formula); }

double Get_Result(void) { return (output.result); }

double Get_Prev_ans(void) { return (output.prev_ans); }

void Set_Formula(char *Value) {
  output.formula = Value;
  //printf("Formula Expected %s\n", output.formula);
}

void Set_Formula_c(int position, char Value) {
  output.formula[position] = Value;
  //printf("Formula Expected %s\n", output.formula);
}

void Set_Result(double Value) { output.result = Value; }

void Set_Prev_ans(double Value) { output.prev_ans = Value; }

int Increment_Formula(int Direction) {
  return (output.pos = output.pos + Direction);
}

int Increment_Pos(int Direction) {
  return (equation.pos = equation.pos + Direction);
}

void Reset_Formula_pos(void) { output.pos = 0; }

// Allocate memory for input string
int allocate_memory() {
  // Calloc enough memory for the input string pointers
  // Allocate arbituary amount of memory for initial max number of strings (10)

  equation.input = (char **)calloc(MemExpand, sizeof(char *));
  if (equation.input == 0) {
    printf("%sERROR:%s Calloc input memory\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  equation.size = MemExpand;

  return 0;
}

// Expand previously allocated memory for input string
int reallocate_memory() {
  // Takes previously allocated section,
  // Allocates new sizeof(new_chunk + old_chunk)
  // Shifts old_chunk into new chunck

  for (int i = 0; i < equation.pos; i++) {
    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO:%s Equation.Input[%i] Before %s length %i\n",
             DEBUG_M, DEFAULT_COLOUR_M, i, equation.input[i],
             strlen(equation.input[i]));
  }

  equation.input = (char **)realloc(
      equation.input, (equation.size + MemExpand) * sizeof(char *));
  if (equation.input == 0) {
    printf("%sERROR:%s Calloc input memory\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  equation.size = equation.size + MemExpand;

  for (int i = 0; i < equation.pos; i++) {
    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO:%s Equation.Input[%i] After %s  length %i\n",
             DEBUG_M, DEFAULT_COLOUR_M, i, equation.input[i],
             strlen(equation.input[i]));
  }

  for (int i = equation.pos; i < equation.size; i++) {
    equation.input[i] = "\0";
  }

  for (int i = 0; i < equation.size; i++) {
    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO:%s Equation.Input[%i] After %s  length %i\n",
             DEBUG_M, DEFAULT_COLOUR_M, i, equation.input[i],
             strlen(equation.input[i]));
  }

  return 0;
}

// Append equation strings into a single string
int Input_append(char *item) {
  int num_char = equation.pos;
  char *new_string = (char *)calloc((strlen(item) + 1), sizeof(char));

  if (new_string == 0) {
    printf("%sERROR:%s Could not create memory for new_string\n", ERROR_M,
           DEFAULT_COLOUR_M);
  }
  strncpy(&new_string[0], item, strlen(item));

  equation.input[num_char] = &new_string[0];
  if (Get_Debug() == 1) {
    printf("%sDEBUG_INFO:%s Item expected %s\n", DEBUG_M, DEFAULT_COLOUR_M,
           item);
    printf("%sDEBUG_INFO:%s String copied %s\n", DEBUG_M, DEFAULT_COLOUR_M,
           new_string);
    printf("%sDEBUG_INFO:%s String stored %s\n", DEBUG_M, DEFAULT_COLOUR_M,
           (equation.input[num_char]));
    printf("%sDEBUG_INFO:%s Num_char %i\n", DEBUG_M, DEFAULT_COLOUR_M,
           num_char);
  }

  if (strcmp(new_string, (equation.input[num_char])) != 0) {
    printf("%sERROR:%s String copied not equal to string stored\n", ERROR_M,
           DEFAULT_COLOUR_M);
  }

  // Check that memory has been allocated
  if (equation.pos == 0) {
    output.formula = (char *)calloc(MemExpand, sizeof(char));
    if (output.formula == 0) {
      printf("%sERROR:%s Calloc output memory\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
    strncpy(output.formula, equation.input[0], strlen(equation.input[0]));
    if (Get_Debug() == 1 || Get_System() == 1)
      printf("%sDEBUG_INFO:%s formula contains %s\n", DEBUG_M, DEFAULT_COLOUR_M,
             output.formula);
  }

  else {
    // Reallocate memory if needed
    strcat(output.formula, equation.input[equation.pos]);
    if (Get_Debug() == 1 || Get_System() == 1)
      printf("%sDEBUG_INFO:%s formula contains %s\n", DEBUG_M, DEFAULT_COLOUR_M,
             output.formula);
  }
  // Call function to display equation on screen
  if (clear_equation() != 0)
    printf("%sERROR:%s Could not clear equation\n", ERROR_M, DEFAULT_COLOUR_M);
  if (draw_equation() != 0)
    printf("%sERROR:%s Could not draw equation\n", ERROR_M, DEFAULT_COLOUR_M);
  equation.pos++;

  return 0;
}

// Draw the equation on the screen
int draw_equation() {
  // Draws specific character passed into function
  int x_min = Get_Area(24, 0);
  int x_max = Get_Area(21, 1);
  int y_min = Get_Area(24, 2);
  int y_max = Get_Area(24, 3);

  int offset = 0;

  if (LCD_Cell_Colour(x_min, x_max, y_min, y_max, LCD_COLOR_BLACK,
                      LCD_COLOR_WHITE) != 0) {
    printf("%sERROR:%s Could not clear cell\n", ERROR_M, DEFAULT_COLOUR_M);
  }

  // Find center of cell given
  int x_pos = ((x_max - x_min) / 2.0) + x_min;
  int y_pos = ((y_max - y_min) / 2.0) + y_min;

  if (Get_Debug() == 1)
    printf(
        "%sDEBUG_INFO:%s x_min %i, x_max %i, y_min %i, y_max %i, x_pos %i, "
        "y_pos %i\n",
        DEBUG_M, DEFAULT_COLOUR_M, x_min, x_max, y_min, y_max, x_pos, y_pos);

  // Roll around the display
  int LCDResultlen = 20;

  if (equation.pos > LCDResultlen) {
    offset = equation.pos - LCDResultlen;
  }

  char *temp_equation = "";
  if (equation.pos == 0) {
    temp_equation = (char *)calloc(LCDResultlen, sizeof(char));
    if (output.formula == 0) {
      printf("%sERROR:%s Calloc output memory", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
    temp_equation[0] = output.formula[0];
  } else {
    for (int i = offset; i < equation.pos; i++) {
      temp_equation[i - offset] = output.formula[i];
    }
  }

  char *temp = &output.formula[offset];

  BSP_LCD_SetFont(&Font16);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
  BSP_LCD_DisplayStringAt(x_min + 5, y_pos, (uint8_t *)temp, LEFT_MODE);

  return 0;
}
#include "Ass-02-Graph.h"

// Initilise screen to the graph mode
void GraphInit() {
  // Clear screen
  BSP_LCD_Clear(LCD_COLOR_WHITE);
  BSP_LCD_SetFont(&Font12);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

  // Reset the axis range to defaults
  layout.x_axis_min = DEFAULT_X_MIN;
  layout.x_axis_max = DEFAULT_X_MAX;
  layout.y_axis_min = DEFAULT_Y_MIN;
  layout.y_axis_max = DEFAULT_Y_MAX;

  graph.x_min = layout.x_axis_min;
  graph.x_max = layout.x_axis_max;
  graph.y_min = layout.y_axis_min;
  graph.y_max = layout.y_axis_max;
  graph.delta = DEFAULT_DELTA;

  // Set basic layout of calculator grid
  if (graph_layout() != 0) {
    printf("%sERROR:%s Unable to draw layout", ERROR_M, DEFAULT_COLOUR_M);
  }
  // Initilise numpad symbol layout
  if (draw_axisnum() != 0) {
    printf("%sERROR:%s Unable to draw axis numbers", ERROR_M, DEFAULT_COLOUR_M);
  }
}

// Calculates answer to formula for given delta
void GraphProcess() {
  double x_min = graph.x_min;
  double x_max = graph.x_max;
  double y_min = graph.y_min;
  double y_max = graph.y_max;
  double delta = graph.delta;

  // Store the string
  static char graph_formula[50];

  // Itterate from min range to max range
  // In steps of Delta
  // Calculate function at that position
  // Draw a line between the previous coordinates and current coordinates
  strcpy(graph_formula, Get_Formula());
  graph.formula = graph_formula;
  if (parseFormula() == 0) {
    Set_Prev_ans(Get_Result());

    graph.prev_ans = Get_Result();
    for (double i = x_min + delta; i <= x_max;) {
      Set_Formula(graph_formula);
      Set_Graph_Increment(i);

      if (parseFormula() == 0) {
        Set_Prev_ans(Get_Result());
        BSP_LCD_DrawLine(Map_X_Display(i - delta),
                         (Map_Y_Display(graph.prev_ans)), Map_X_Display(i),
                         (Map_Y_Display(Get_Result())));
        // printf("Draw Line From point(%lf,%lf) to point(%lf, %lf)\n",i-delta,
        // graph.prev_ans, i, Get_Result()); printf("Mapp Line From
        // point(%lf,%lf) to point(%lf, %lf)\n",Map_X_Display(i - delta),
        // Map_Y_Display(graph.prev_ans), Map_X_Display(i),
        // Map_Y_Display(Get_Result()));
        graph.prev_ans = Get_Result();
      } else {
        break;
      }
      i = i + delta;
    }
  }
}

// Map the xy range to the screen xy range
double Map_X_Display(double Input) {
  return ((Input - graph.x_min) / (graph.x_max - graph.x_min) *
              (BSP_LCD_GetXSize() - 0) +
          0);
}

// Map the xy range to the screen xy range
double Map_Y_Display(double Input) {
  return (BSP_LCD_GetYSize() -
          ((Input - graph.y_min) / (graph.y_max - graph.y_min) *
               (BSP_LCD_GetYSize() - 0) +
           0));
}

int graph_layout() {
  // LCD X and Y Size
  int display_height = BSP_LCD_GetYSize();
  int display_width = BSP_LCD_GetXSize();

  int x_axis = display_height / 2;
  int y_axis = display_width / 2;

  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

  BSP_LCD_DrawVLine(y_axis, 0, display_height);
  BSP_LCD_DrawHLine(0, x_axis, display_width);

  return 0;
}

// Draw numpad layout
int draw_axisnum() {
  int display_height = BSP_LCD_GetYSize();
  int display_width = BSP_LCD_GetXSize();

  int x_axis = display_height / 2;
  int y_axis = display_width / 2;
  // Print X AXIS values
  int x_axis_min = layout.x_axis_min;
  int x_axis_max = layout.x_axis_max;

  // Spacing between x axis values
  int x_spacing = display_width / MAX_AXIS_NUM;
  int x_num_increment = (x_axis_max - x_axis_min) / MAX_AXIS_NUM;
  double printnum = 0;
  char num_str[50];

  BSP_LCD_SetFont(&Font12);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

  for (int i = 0; i <= MAX_AXIS_NUM; i++) {
    printnum = (x_axis_min + i * x_num_increment);
    snprintf(num_str, 50, "%g", printnum);
    // printf("X axis numbers %s\n", num_str);
    BSP_LCD_DisplayStringAt((i * x_spacing), x_axis + (0.5 * CHAR_HEIGHT),
                            (uint8_t *)num_str, CENTER_MODE);
  }
  // Print Y AXIS values
  int y_axis_min = layout.y_axis_min;
  int y_axis_max = layout.y_axis_max;

  // Spacing between y axis values
  int y_spacing = display_height / MAX_AXIS_NUM;
  int y_num_increment = (y_axis_max - y_axis_min) / MAX_AXIS_NUM;

  BSP_LCD_SetFont(&Font12);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
  for (int i = 0; i <= MAX_AXIS_NUM; i++) {
    printnum = y_axis_max - i * y_num_increment;
    snprintf(num_str, 50, "%g", printnum);
    BSP_LCD_DisplayStringAt(y_axis - CHAR_HEIGHT, (i * y_spacing),
                            (uint8_t *)num_str, CENTER_MODE);
  }

  return 0;
}

// Set axis scale to given value
void set_axis_scale(int i, double Value) {
  if (i == 2) {
    layout.x_axis_min = Value;
  } else if (i == 3) {
    layout.x_axis_max = Value;
  } else if (i == 4) {
    layout.y_axis_min = Value;
  } else if (i == 5) {
    layout.y_axis_max = Value;
  }
}

// Get axis scale from given value
double Get_axis_scale(int Value) {
  if (Value == 1) {
    return (layout.x_axis_min);
  } else if (Value == 2) {
    return (layout.x_axis_max);
  } else if (Value == 3) {
    return (layout.y_axis_min);
  } else if (Value == 4) {
    return (layout.y_axis_max);
  }
  return (0);
}

// Recale graph to new limits
void rescale_graph() {
  GraphInit();
  if (graph.formula != NULL) {
    Set_Formula(graph.formula);
    GraphProcess();
  } else {
    printf("%sERROR:%s No formula currently entered to rescale\n", ERROR_M,
           DEFAULT_COLOUR_M);
  }
}

// Reset scale to default
void reset_scale() {
  set_axis_scale(2, DEFAULT_X_MIN);
  set_axis_scale(3, DEFAULT_X_MAX);
  set_axis_scale(4, DEFAULT_Y_MIN);
  set_axis_scale(5, DEFAULT_Y_MAX);
  GraphInit();
  GraphProcess();
}

// Print help messages for graph
void graph_help() {
  printf("NOTE: This is unfinished\n");
  printf("Graph accepts equation input with unknown parameter 'X'\n");
  printf("'graph' must be entered before one of these functions\n");
  printf("reset_scale: resets scale to default, redraws graph\n");
  printf("rescale: redraws current graph with current scale\n");
  printf("scale: sets scale to <x_min> <x_max> <y_min> <y_max>\n");
  printf("rad: change units of angle to radians\n");
  printf("deg: change units of angle to degrees\n");
}

int Graph_StringProcess(char *command_line, int i) {
  static double prev_ans = 0;
  char **array_of_words_p;

  int word_count = string_parser(command_line, &array_of_words_p);

  if (Get_System() == 1) {
    for (int i = 0; i < word_count; i++) {
      printf("%sSYSTEM_INFO:%s Word %i: %s\n", SYS_M, DEFAULT_COLOUR_M, i,
             array_of_words_p[i]);
    }
  }

  // Graph mode ON
  if (word_count > 0) {
    if (command_parser(&array_of_words_p, word_count, &prev_ans) == 1) {
    } else {
      Set_Formula(array_of_words_p[0]);
      Set_Result(0);
      GraphInit();
      GraphProcess();
    }

    free(array_of_words_p[0]);
    free(array_of_words_p);

    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO:%s Arrays have been freed\n", DEBUG_M,
             DEFAULT_COLOUR_M);

  } else {
    printf("%sERROR:%s No strings detected\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  return 0;
}

void Set_Graph_Increment(double Value) { graph.increment = Value; }

double Get_Graph_Increment() { return (graph.increment); }
/*
 * Author      : Mitchell Marotta C3258958
 *               Taylor Young C3206230
 * Date        : 4 May 2018
 * Description : Assignment 2
 *               Code common to Q1 and Q2
 */

#include "Ass-02.h"

// List of function names, pointers to that function, method of use, description
// of function
const animation_s Title_Animation[] = {
    {LCD_COLOR_BLUE},         {LCD_COLOR_GREEN},
    {LCD_COLOR_RED},          {LCD_COLOR_CYAN},
    {LCD_COLOR_MAGENTA},      {LCD_COLOR_YELLOW},
    {LCD_COLOR_LIGHTBLUE},    {LCD_COLOR_LIGHTGREEN},
    {LCD_COLOR_LIGHTRED},     {LCD_COLOR_LIGHTCYAN},
    {LCD_COLOR_LIGHTMAGENTA}, {LCD_COLOR_LIGHTYELLOW},
    {LCD_COLOR_DARKBLUE},     {LCD_COLOR_DARKGREEN},
    {LCD_COLOR_DARKRED},      {LCD_COLOR_DARKCYAN},
    {LCD_COLOR_DARKMAGENTA},  {LCD_COLOR_DARKYELLOW},
    {LCD_COLOR_WHITE},        {LCD_COLOR_LIGHTGRAY},
    {LCD_COLOR_GRAY},         {LCD_COLOR_DARKGRAY},
    {LCD_COLOR_BLACK},        {LCD_COLOR_BROWN},
    {LCD_COLOR_ORANGE},       {NULL}};

// clang-format off
const command_s Command_list[] = {
    {"add",     &add_function,     "add <num 1> . + . <num N>", "Add one or more numbers"},
    {"sub",     &sub_function,     "sub <num 1> - <num 2>",     "Subtract two numbers"},
    {"mul",     &mul_function,     "mul <num 1> . * . <num N>", "Multiply one or more numbers"},
    {"div",     &div_function,     "div <num 1> / <num 2>",     "Divide two numbers"},
    {"sin",     &sin_function,     "sin <num 1> <rad|deg>",     "sin number in radians or degrees"},
    {"cos",     &cos_function,     "cos <num 1> <rad|deg>",     "cos number in radians or degrees"},
    {"tan",     &tan_function,     "tan <num 1> <rad|deg>",     "tan number in radians or degrees"},
    {"asin",    &asin_function,    "asin <num 1> <rad|deg>",    "asin number in radians or degrees"},
    {"acos",    &acos_function,    "acos <num 1> <rad|deg>",    "acos number in radians or degrees"},
    {"atan",    &atan_function,    "atan <num 1> <rad|deg>",    "atan number in radians or degrees"},
    {"pow",     &pow_function,     "pow <num 1> ^ <num 2>",     "Power base, exponent"},
    {"sqrt",    &sqrt_function,    "sqrt <num 1>",              "Add one or more numbers"},
    {"ln",      &ln_function,      "ln <num 1>",                "Add one or more numbers"},
    {"log",     &log_function,     "log <num 1>",               "Add one or more numbers"},
    {"exp",     &exp_function,     "exp <num 1>",               "Add one or more numbers"},
    {"formula", &formula_function, "formula <on|off>",          "Allows Formula Input"},
    {"graph",   &graph_function,   "graph <on|off>",            "Allows graph output on LCD"},
    {"debug",   &debug_function,   "debug <on|off>",            "Display debug messages"},
    {"system",  &system_function,  "system <on|off>",           "Display system messages"},
    {"clear",   &clear_function,   "reset",                     "Clear terminal screen"},
    {"reset",   &reset_function,   "clear",                     "Reset terminal scrollback"},
    {"help",    &help_function,    "help [command]",            "Display help messages"},
    {NULL,      NULL,              NULL,                        NULL}};

// clang-format on

// If a command is called function decides which function pointer to return
int command_parser(char **array_of_words_p[], int word_count,
                   double *prev_ans) {
  double result = 0;
  int i = 0;

  // While we haven't checked the whole list
  while (Command_list[i].NameString != NULL) {
    // If we find the function we want, call it
    if (strcmp((*array_of_words_p)[0], Command_list[i].NameString) == 0) {
      if (Get_Debug() == 1)
        printf("Operation: %s\n", Command_list[i].NameString);
      // If the function we wanted returned success
      if (Command_list[i].Function_p(array_of_words_p, word_count, &result) ==
          0) {
        Set_Result(result);
        *prev_ans = result;
        if (i <= 14)
          return 0;
        else
          return 1;
      } else {
        return -1;
      }
    }
    i++;
  }
  return -1;
}

// If help is called
// Function decides if specific help is to be diplayed or all
int help_parser(char **array_of_words_p[], int word_count) {
  int i = 0;

  printf("%s" HELP_M
         "%s"
         "\n",
         KGRN, "Format", "Description", KNRM);
  if (word_count > 1) {
    // While we haven't checked the whole list
    while (Command_list[i].NameString != NULL) {
      // If we find the function we wanted, display the help message
      if (strcmp((*array_of_words_p)[1], Command_list[i].NameString) == 0) {
        if (Get_Debug() == 1)
          printf("Operation: %s\n", Command_list[i].NameString);
        // Print Specific command list thing
        printf(HELP_M "\n", Command_list[i].HelpString,
               Command_list[i].DescriptionString);
        return 0;
      }
      i++;
    }
  } else if (word_count == 1) {
    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO:%s No Operation selected\n", DEBUG_M,
             DEFAULT_COLOUR_M);
    // Loop through all command list and print
    while (Command_list[i].NameString != NULL) {
      printf(HELP_M "\n", Command_list[i].HelpString,
             Command_list[i].DescriptionString);
      i++;
    }
    return 0;
  }
  return 1;
}

// clang-format off
/**********************************************************************************************************************
************************************************Recursive Desent Parser************************************************
**********************************************************************************************************************/
// clang-format on

// Takes formula string
// Calls next precedent
// Returns answer at end
double parseFormula() {
  if (Get_System() == 1)
    printf("%sSYSTEM_INFO:%s Formula Parsed: %s\n", SYS_M, DEFAULT_COLOUR_M,
           output.formula);
  output.result = parseSub();
  if (*output.formula == '\0') {
    // return output.result;
    return 0;
  }
  printf("Expected end of output.input but found %c\n", *output.formula);
  printf("Syntax Error\n");
  return 1;
}

// Calls next precedent
// Calculates relative function
// Returns answer at end
double parseSub() {
  double sub_1 = parseSum();
  while (*output.formula == '-') {
    ++output.formula;
    double sub_2 = parseSum();
    sub_1 = sub_1 - sub_2;
  }
  return sub_1;
}

// Calls next precedent
// Calculates relative function
// Returns answer at end
double parseSum() {
  double sum_1 = parsePro();
  while (*output.formula == '+') {
    ++output.formula;
    double sum_2 = parsePro();
    sum_1 = sum_1 + sum_2;
  }
  return sum_1;
}

// Calls next precedent
// Calculates relative function
// Returns answer at end
double parsePro() {
  double pro_1 = parseDiv();
  while (*output.formula == 'x' || *output.formula == '*') {
    ++output.formula;
    double pro_2 = parseDiv();
    pro_1 = pro_1 * pro_2;
  }
  return pro_1;
}

// Calls next precedent
// Calculates relative function
// Returns answer at end
double parseDiv() {
  double div_1 = parsePow();
  while (*output.formula == '/') {
    ++output.formula;
    double div_2 = parsePow();
    div_1 = div_1 / div_2;
  }
  return div_1;
}

// Calls next precedent
// Calculates relative function
// Returns answer at end
double parsePow() {
  double pow_1 = parseFactor();
  while (*output.formula == '^') {
    ++output.formula;
    double pow_2 = parseFactor();
    pow_1 = pow(pow_1, pow_2);
  }
  return pow_1;
}

// Decides whether next factor is a
// Number
// Word operation
// Bracket
double parseFactor() {
  if (*output.formula >= '0' && *output.formula <= '9') {
    return parseNumber();
  } else if (*output.formula == '-') {
    return parseNumber();
  } else if (*output.formula == '+') {
    return parseNumber();
  } else if (*output.formula == '(') {
    ++output.formula;
    double temp = parseSub();
    ++output.formula;
    return temp;
  }
  // PI
  else if (*output.formula == 'p') {
    ++output.formula;
    if (*output.formula == 'i') {
      ++output.formula;
      return M_PI;
    }
  }
  // sin sqrt
  else if (*output.formula == 's') {
    ++output.formula;
    if (*output.formula == 'i') {
      ++output.formula;
      if (*output.formula == 'n') {
        ++output.formula;
        if (*output.formula == '(') {
          ++output.formula;
          double temp = parseSub();
          if(Get_Angle_Mode() == 1){
        	  temp = sin(temp);
          }
          else{
        	  temp = sin(temp * M_PI / 180);
          }
          ++output.formula;
          return temp;
        }
      }
    } else if (*output.formula == 'q') {
      ++output.formula;
      if (*output.formula == 'r') {
        ++output.formula;
        if (*output.formula == 't') {
          ++output.formula;
          if (*output.formula == '(') {
            ++output.formula;
            double temp = parseSub();
            temp = sqrt(temp);
            ++output.formula;
            return temp;
          }
        }
      }
    }
  }
  // cos
  else if (*output.formula == 'c') {
    ++output.formula;
    if (*output.formula == 'o') {
      ++output.formula;
      if (*output.formula == 's') {
        ++output.formula;
        if (*output.formula == '(') {
          ++output.formula;
          double temp = parseSub();
          if(Get_Angle_Mode() == 1){
                  	  temp = cos(temp);
                    }
                    else{
                  	  temp = cos(temp * M_PI / 180);
                    }
          ++output.formula;
          return temp;
        }
      }
    }
  }
  // tan
  else if (*output.formula == 't') {
    ++output.formula;
    if (*output.formula == 'a') {
      ++output.formula;
      if (*output.formula == 'n') {
        ++output.formula;
        if (*output.formula == '(') {
          ++output.formula;
          double temp = parseSub();
          if(Get_Angle_Mode() == 1){
                  	  temp = tan(temp);
                    }
                    else{
                  	  temp = tan(temp * M_PI / 180);
                    }
          ++output.formula;
          return temp;
        }
      }
    }
  }
  // asin acos atan
  else if (*output.formula == 'a') {
    ++output.formula;
    if (*output.formula == 's') {
      ++output.formula;
      if (*output.formula == 'i') {
        ++output.formula;
        if (*output.formula == 'n') {
          ++output.formula;
          if (*output.formula == '(') {
            ++output.formula;
            double temp = parseSub();
            if(Get_Angle_Mode() == 1){
                    	  temp = asin(temp);
                      }
                      else{
                    	  temp = asin(temp * M_PI / 180);
                      }
            ++output.formula;
            return temp;
          }
        }
      }
    } else if (*output.formula == 'c') {
      ++output.formula;
      if (*output.formula == 'o') {
        ++output.formula;
        if (*output.formula == 's') {
          ++output.formula;
          if (*output.formula == '(') {
            ++output.formula;
            double temp = parseSub();
            if(Get_Angle_Mode() == 1){
                    	  temp = acos(temp);
                      }
                      else{
                    	  temp = acos(temp * M_PI / 180);
                      }
            ++output.formula;
            return temp;
          }
        }
      }
    } else if (*output.formula == 't') {
      ++output.formula;
      if (*output.formula == 'a') {
        ++output.formula;
        if (*output.formula == 'n') {
          ++output.formula;
          if (*output.formula == '(') {
            ++output.formula;
            double temp = parseSub();
            if(Get_Angle_Mode() == 1){
                    	  temp = atan(temp);
                      }
                      else{
                    	  temp = atan(temp * M_PI / 180);
                      }
            ++output.formula;
            return temp;
          }
        }
      }
    } else if (*output.formula == 'n') {
      ++output.formula;
      if (*output.formula == 's') {
        ++output.formula;
        double temp = output.prev_ans;
        return temp;
      }
    }
  }
  // exp
  else if (*output.formula == 'e') {
    ++output.formula;
    if (*output.formula == 'x') {
      ++output.formula;
      if (*output.formula == 'p') {
        ++output.formula;
        if (*output.formula == '(') {
          ++output.formula;
          double temp = parseSub();
          temp = exp(temp);
          ++output.formula;
          return temp;
        }
      }
    }
  }
  // ln log10
  else if (*output.formula == 'l') {
    ++output.formula;
    if (*output.formula == 'n') {
      ++output.formula;
      if (*output.formula == '(') {
        ++output.formula;
        double temp = parseSub();
        temp = log(temp);
        ++output.formula;
        return temp;
      }
    } else if (*output.formula == 'o') {
      ++output.formula;
      if (*output.formula == 'g') {
        ++output.formula;
        if (*output.formula == '(') {
          ++output.formula;
          double temp = parseSub();
          temp = log10(temp);
          ++output.formula;
          return temp;
        }
      }
    }
  } else if (Get_Graph_Mode() == 1) {
    if (*output.formula == 'X') {
    	++output.formula;
      return (Get_Graph_Increment());
    }
  } else {
    printf("Syntax Error\n");
    printf("Unknown symbol %c\n", *output.formula);
  }
  return 0;
}

// If the current factor is a number
// Decide if it is nugative or positive
// Find any decimals
// Return number as double
double parseNumber() {
  double number = 0;
  int neg_flag = 1;
  if (*output.formula >= '0' && *output.formula <= '9') {
  } else if (*output.formula == '-') {
    neg_flag = -1;
    ++output.formula;
  } else if (*output.formula == '+') {
    neg_flag = 1;
    ++output.formula;
  } else {
    printf("Syntax Error\n");
  }

  while (*output.formula >= '0' && *output.formula <= '9') {
    number = number * 10;
    number = number + (int)(*output.formula - '0');
    ++output.formula;
  }

  if (*output.formula == '.') {
    ++output.formula;

    // Check the next character is a number, else error

    if (*output.formula >= '0' && *output.formula <= '9') {
      double weight = 1;
      while (*output.formula >= '0' && *output.formula <= '9') {
        weight = weight / 10.0;
        double scaled = (int)(*output.formula - '0') * weight;
        number = number + scaled;
        ++output.formula;
      }
    } else {
      printf("Syntax Error\n");
    }
  }
  if (Get_System() == 1)
    printf("%sSYSTEM_INFO:%s Number Found: %lf\n", SYS_M, DEFAULT_COLOUR_M,
           (number * neg_flag));
  return (number * neg_flag);
}

// clang-format off
/***********************************************************************************************************************
 ****************************************************Title Animation****************************************************
 **********************************************************************************************************************/
// clang-format on

int title_animation() {
  BSP_LCD_Clear(LCD_COLOR_WHITE);
  BSP_LCD_SetFont(&Font12);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

  int j = 0;
  static int button_debounce = 0;
  static int off_debounce = 0;

  // Increment through the lst of colours
  while (Title_Animation[j].BGColour != NULL) {
    BSP_LCD_Clear(Title_Animation[j].BGColour);
    for (int i = 0; i < 1500; i++) {
      // Break if the user touches the screen
      if (BSP_TP_GetDisplayPoint(&display) == 0) {
        button_debounce++;
        if (button_debounce >= 50) {
          BSP_LCD_Clear(LCD_COLOR_WHITE);
          return 0;
        }
      } else {
        off_debounce++;
        // User is definately not pressing a button, reset the holding flag
        if (off_debounce > 100) {
          button_debounce = 0;
          off_debounce = 0;
        }
      }
    }
    j++;
  }

  BSP_LCD_Clear(LCD_COLOR_WHITE);

  return 0;
}

// clang-format off
/***********************************************************************************************************************
 *********************************************************Other*********************************************************
 **********************************************************************************************************************/
// clang-format on

// STEPIEN: Added two touch panel functions to make the interface more
//          consistent with the LCD BSP.

#ifdef STM32F407xx
uint8_t BSP_TP_Init(void) {
  // Initialise the interface and calibrate
  TP_Init();  // This is an empty function since done by STM32CubeMX
  TouchPanel_Calibrate();

  return 0;
}

uint8_t BSP_TP_GetDisplayPoint(Coordinate *pDisplay) {
  Coordinate *pScreen;

  pScreen = Read_Ads7846();
  if (pScreen == NULL) {
    return 1;  // Error reading the touch panel
  }
  if (getDisplayPoint(pDisplay, pScreen, &matrix) == DISABLE) {
    return 1;  // Error in LCD
  }
  return 0;
}
#endif
// TODO Implement backspace handler

/*
 * Author      : Mitchell Marotta C3258958
 *               Taylor Young C3206230
 * Date        : 4 May 2018
 * Description : Q1
 *               Command line parser
 *               Works in both windows and in putty
 */

#include "Ass-02.h"
#ifdef STM32F407xx
#include "usart.h"
#endif

// Constant strings used for identifying the function requested
const char *ADDstr = "add";
const char *SUBstr = "sub";
const char *MULstr = "mul";
const char *DIVstr = "div";
const char *SINstr = "sin";
const char *COSstr = "cos";
const char *TANstr = "tan";
const char *ASINstr = "asin";
const char *ACOSstr = "acos";
const char *ATANstr = "atan";
const char *POWstr = "pow";
const char *SQRTstr = "sqrt";
const char *LNstr = "ln";
const char *LOGstr = "log";
const char *EXPstr = "exp";
const char *FORMULAstr = "formula";
const char *DEBUGstr = "debug";
const char *HELPstr = "help";

const char *RADstr = "rad";
const char *DEGstr = "deg";
const char *PIstr = "pi";
const char *ANSstr = "ans";

// clang-format off
/***********************************************************************************************************************
************************************************Command Line Parser Init************************************************
***********************************************************************************************************************/
// clang-format on

void CommandLineParserInit(void) {
  // Print welcome message
  printf(RESET_M);
  printf(CLEAR_M);
  printf(KNRM);
  printf("ELEC3730 Assignment 2\n");
  printf("Command Line Parser\n");
}

// clang-format off
/***********************************************************************************************************************
**********************************************Command Line Parser Process***********************************************
***********************************************************************************************************************/
// clang-format on

// Takes in commandline characters from putty or windows
void CommandLineParserProcess(void) {
  char c;
  static int i = 0;
  static char command_line[101];

// Check for input and echo back
#ifdef STM32F407xx

  if (Get_First_Time() == 1) {
    Set_First_Time(0);
    printf("--> Enter text: ");
  }
  if (HAL_UART_Receive(&huart2, &c, 1, 0x0) == HAL_OK) {
    printf("%c", c);
    HAL_GPIO_TogglePin(GPIOD, LD4_Pin);  // Toggle LED4

    command_line[i] = c;
    i++;

    // If we get a return character then process the string
    if (c == '\r' || i > 101) {
      printf("\n");
      command_line[i - 1] = '\0';
      if (Get_Graph_Mode() == 0) {
        if (StringProcess(&command_line, i) != 0)
          printf("%sERROR:%s Could not process string\n", ERROR_M,
                 DEFAULT_COLOUR_M);
      } else if (Get_Graph_Mode() == 1) {
        if (Graph_StringProcess(&command_line, i) != 0)
          printf("%sERROR:%s Could not process string\n", ERROR_M,
                 DEFAULT_COLOUR_M);
      }

      i = 0;
      Set_First_Time(1);
    }
  }

#else

  // Get one line of input
  printf("--> Enter text: ");
  i = 0;
  c = getchar();

  // If we get a new line character then process the string
  while (c != '\n') {
    command_line[i] = c;
    i++;
    c = getchar();
  }
  command_line[i] = 0;
  if (StringProcess(&command_line, i) != 0)
    printf("%sERROR:%s Could not process string\n", ERROR_M, DEFAULT_COLOUR_M);

  i = 0;

#endif
}

// Takes string, converts to words
// Replaces PI and ANS with appropriate numbers
// Processes strings to result
int StringProcess(char *command_line, int i) {
  static double prev_ans = 0;
  char **array_of_words_p;

  int word_count = string_parser(command_line, &array_of_words_p);

  if (Get_System() == 1) {
    for (int i = 0; i < word_count; i++) {
      printf("%sSYSTEM_INFO:%s Word %i: %s\n", SYS_M, DEFAULT_COLOUR_M, i,
             array_of_words_p[i]);
    }
  }

  // If words were detected, and we are using the normal mode
  if (word_count > 0 && Get_Formula_Mode() == 0) {
    if (Get_System() == 1)
      printf("%sSYSTEM_INFO:%s Word Count = %i\n", SYS_M, DEFAULT_COLOUR_M,
             word_count);

    char dtos[50];
    // Check the 2 value parameters for pi
    for (int j = 1; j < word_count; j++) {
      if ((strcmp("PI", array_of_words_p[j]) == 0) ||
          (strcmp("pi", array_of_words_p[j]) == 0) ||
          (strcmp("Pi", array_of_words_p[j]) == 0)) {
        if (Get_Debug() == 1)
          printf("%sDEBUG_INFO:%s Constant PI found\n", DEBUG_M,
                 DEFAULT_COLOUR_M);
        snprintf(dtos, 50, "%lf", M_PI);
        array_of_words_p[j] = dtos;
      }
    }

    // Check the 2 value parameters for ans
    for (int j = 1; j < word_count; j++) {
      if ((strcmp("ANS", array_of_words_p[j]) == 0) ||
          (strcmp("ans", array_of_words_p[j]) == 0)) {
        if (Get_Debug() == 1)
          printf("%sDEBUG_INFO:%s Constant ANS found\n", DEBUG_M,
                 DEFAULT_COLOUR_M);
        snprintf(dtos, 50, "%lf", prev_ans);
        array_of_words_p[j] = dtos;
      }
    }

    // Check if command parser returned a valid function
    int mode = -1;
    mode = command_parser(&array_of_words_p, word_count, &prev_ans);
    if (mode == -1) {
      printf("%sERROR:%s Unknown Operation\n", ERROR_M, DEFAULT_COLOUR_M);
    } else if (mode == 0) {
      Set_Result(prev_ans);
      Set_Prev_ans(prev_ans);
      // printf("The result is %s%g%s\n", KGRN, Get_Result(), KNRM);
      printf("Result %g\n", Get_Prev_ans());
      if (Get_Debug() == 1) printf("Ans %g\n", Get_Prev_ans());
    } else {
      // Must have changed debug, formula or help
    }

    free(array_of_words_p[0]);
    free(array_of_words_p);

    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO:%s Arrays have been freed\n", DEBUG_M,
             DEFAULT_COLOUR_M);
  }

  // Formula mode ON
  else if (Get_Formula_Mode() == 1) {
    if (command_parser(&array_of_words_p, word_count, &prev_ans) == 1) {
    } else {
      Set_Formula(array_of_words_p[0]);
      Set_Result(0);

      // Call the recursive decent parser
      if (parseFormula() == 0) {
        Set_Prev_ans(Get_Result());
        printf("The result is %g\n", Get_Result());
        if (Get_Debug() == 1) printf("Answer stored is %lf\n", Get_Prev_ans());
      }
    }

    free(array_of_words_p[0]);
    free(array_of_words_p);

    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO:%s Arrays have been freed\n", DEBUG_M,
             DEFAULT_COLOUR_M);

  } else {
    printf("%sERROR:%s No strings detected\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  return 0;
}

// clang-format off
/***********************************************************************************************************************
**************************************************Operation Function****************************************************
***********************************************************************************************************************/
// clang-format on

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int add_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered ADD function\n", DEBUG_M, DEFAULT_COLOUR_M);
  double value_1 = 0;
  double value_2 = 0;
  // For each number perform the functions calculation
  for (int i = 1; i < word_count; i++) {
    // Read in next parameter, used as number for calculation
    if (sscanf((*array_of_words_p)[i], "%lf", &value_2) != 1) {
      printf("%sERROR:%s Found unknown argument %s\n", ERROR_M,
             DEFAULT_COLOUR_M, (*array_of_words_p)[i]);
      return 1;
    }
    value_1 += value_2;
  }
  *result = value_1;
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int sub_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered SUB function\n", DEBUG_M, DEFAULT_COLOUR_M);
  double value_1 = 0;
  double value_2 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[2], "%lf", &value_2) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  *result = value_1 - value_2;
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int mul_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered MUL function\n", DEBUG_M, DEFAULT_COLOUR_M);
  double value_1 = 1;
  double value_2 = 0;
  // For each number perform the functions calculation
  for (int i = 1; i < word_count; i++) {
    // Read in next parameter, used as number for calculation
    if (sscanf((*array_of_words_p)[i], "%lf", &value_2) != 1) {
      printf("%sERROR:%s Found unknown argument %s\n", ERROR_M,
             DEFAULT_COLOUR_M, (*array_of_words_p)[i]);
      return 1;
    }
    value_1 = value_1 * value_2;
  }
  *result = value_1;
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int div_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered DIV function\n", DEBUG_M, DEFAULT_COLOUR_M);
  double value_1 = 0;
  double value_2 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[2], "%lf", &value_2) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  *result = value_1 / value_2;
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int sin_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered SIN function\n", DEBUG_M, DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  if (word_count > 1) {
    // Read in next parameter, used as number for calculation
    if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
      printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("%sERROR:%s Insufficient Arguments\n", ERROR_M, DEFAULT_COLOUR_M);
  }
  if (word_count > 2) {
    // If radians don't need to alter number
    if (strcmp(RADstr, (*array_of_words_p)[2]) == 0) {
    }
    // If degrees, number needs to be converted to radians for function
    else if (strcmp(DEGstr, (*array_of_words_p)[2]) == 0) {
      value_1 = value_1 * M_PI / 180;
    }
  } else {
    // Assume radians
  }
  *result = sin(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int cos_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered COS function\n", DEBUG_M, DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  if (word_count > 1) {
    // Read in next parameter, used as number for calculation
    if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
      printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("%sERROR:%s Insufficient Arguments\n", ERROR_M, DEFAULT_COLOUR_M);
  }
  if (word_count > 2) {
    // If radians don't need to alter number
    if (strcmp(RADstr, (*array_of_words_p)[2]) == 0) {
    }
    // If degrees, number needs to be converted to radians for function
    else if (strcmp(DEGstr, (*array_of_words_p)[2]) == 0) {
      value_1 = value_1 * M_PI / 180;
    }
  } else {
    // Assume radians
  }
  *result = cos(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int tan_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered TAN function\n", DEBUG_M, DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  if (word_count > 1) {
    // Read in next parameter, used as number for calculation
    if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
      printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("%sERROR:%s Insufficient Arguments\n", ERROR_M, DEFAULT_COLOUR_M);
  }
  if (word_count > 2) {
    // If radians don't need to alter number
    if (strcmp(RADstr, (*array_of_words_p)[2]) == 0) {
    }
    // If degrees, number needs to be converted to radians for function
    else if (strcmp(DEGstr, (*array_of_words_p)[2]) == 0) {
      value_1 = value_1 * M_PI / 180;
    }
  } else {
    // Assume radians
  }
  *result = tan(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int asin_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered ARCSIN function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  if (word_count > 1) {
    // Read in next parameter, used as number for calculation
    if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
      printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("%sERROR:%s Insufficient Arguments\n", ERROR_M, DEFAULT_COLOUR_M);
  }
  if (word_count > 2) {
    // If radians don't need to alter number
    if (strcmp(RADstr, (*array_of_words_p)[2]) == 0) {
    }
    // If degrees, number needs to be converted to radians for function
    else if (strcmp(DEGstr, (*array_of_words_p)[2]) == 0) {
      value_1 = value_1 * M_PI / 180;
    }
  } else {
    // Assume radians
  }
  *result = asin(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int acos_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered ARCCOS function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  if (word_count > 1) {
    // Read in next parameter, used as number for calculation
    if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
      printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("%sERROR:%s Insufficient Arguments\n", ERROR_M, DEFAULT_COLOUR_M);
  }
  if (word_count > 2) {
    // If radians don't need to alter number
    if (strcmp(RADstr, (*array_of_words_p)[2]) == 0) {
    }
    // If degrees, number needs to be converted to radians for function
    else if (strcmp(DEGstr, (*array_of_words_p)[2]) == 0) {
      value_1 = value_1 * M_PI / 180;
    }
  } else {
    // Assume radians
  }
  *result = acos(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int atan_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered ARCTAN function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  if (word_count > 1) {
    // Read in next parameter, used as number for calculation
    if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
      printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("%sERROR:%s Insufficient Arguments\n", ERROR_M, DEFAULT_COLOUR_M);
  }
  if (word_count > 2) {
    // If radians don't need to alter number
    if (strcmp(RADstr, (*array_of_words_p)[2]) == 0) {
    }
    // If degrees, number needs to be converted to radians for function
    else if (strcmp(DEGstr, (*array_of_words_p)[2]) == 0) {
      value_1 = value_1 * M_PI / 180;
    }
  } else {
    // Assume radians
  }
  *result = atan(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int pow_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered POWER function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  double value_1 = 0;
  double value_2 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 3) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[2], "%lf", &value_2) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  *result = pow(value_1, value_2);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int sqrt_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered SQUARE ROOT function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 2) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  *result = sqrt(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int ln_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered NATURAL LOG function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 2) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  *result = log(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int log_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered LOG 10 function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 2) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  *result = log10(value_1);
  return 0;
}

// Calculate function with given numbers
// Returns 0 on success
// Returns 1 on failure
int exp_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered EXPONENTIAL function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  double value_1 = 0;
  // From given number(s) calculate the function and store the result
  if (word_count > 2) {
    printf("%sERROR:%s Too many arguments\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  // Read in next parameter, used as number for calculation
  if (sscanf((*array_of_words_p)[1], "%lf", &value_1) != 1) {
    printf("%sERROR:%s Found unknown argument\n", ERROR_M, DEFAULT_COLOUR_M);
    return 1;
  }
  *result = exp(value_1);
  return 0;
}

// Change between setting on and off
int formula_function(char **array_of_words_p[], int word_count,
                     double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered Formula Mode\n", DEBUG_M, DEFAULT_COLOUR_M);
  if (word_count > 1) {
    if (strcmp("on", (*array_of_words_p)[1]) == 0) {
      Set_Formula_Mode(1);
      Set_Graph_Mode(0);
      printf("Formula Mode ON\n");
    } else if (strcmp("off", (*array_of_words_p)[1]) == 0) {
      Set_Formula_Mode(0);
      printf("Formula Mode OFF\n");
    } else {
      printf("%sERROR:%s Unknown formula command\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("Formula mode currently %s\n",
           Get_Formula_Mode() == 0 ? "OFF" : "ON");
  }
  return 0;
}

// Change between setting on and off
int debug_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered Debug Mode\n", DEBUG_M, DEFAULT_COLOUR_M);
  if (word_count > 1) {
    if (strcmp("on", (*array_of_words_p)[1]) == 0) {
      Set_Debug(1);
      printf("Debug ON\n");
    } else if (strcmp("off", (*array_of_words_p)[1]) == 0) {
      Set_Debug(0);
      printf("Debug OFF\n");
    } else {
      printf("%sERROR:%s Unknown debug command\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("Debug messages currently %s\n", Get_Debug() == 0 ? "OFF" : "ON");
  }
  return 0;
}

// Change between setting on and off
int system_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered System Mode\n", DEBUG_M, DEFAULT_COLOUR_M);
  if (word_count > 1) {
    if (strcmp("on", (*array_of_words_p)[1]) == 0) {
      Set_System(1);
      printf("%sSYSTEM_INFO:%s System ON\n", SYS_M, DEFAULT_COLOUR_M);
    } else if (strcmp("off", (*array_of_words_p)[1]) == 0) {
      Set_System(0);
      printf("%sSYSTEM_INFO:%s System OFF\n", SYS_M, DEFAULT_COLOUR_M);
    } else {
      printf("%sERROR:%s Unknown system command\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else {
    printf("%sSYSTEM_INFO:%s System messages currently %s\n", SYS_M,
           DEFAULT_COLOUR_M, Get_System() == 0 ? "OFF" : "ON");
  }
  return 0;
}

// Clear function, clear terminal screen
int clear_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered HELP function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  printf(CLEAR_M);
  return 0;
}

// Reset function, reset terminal scrollback
int reset_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered HELP function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  printf(RESET_M);
  return 0;
}

// Help function, display help messages
int help_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered HELP function\n", DEBUG_M,
           DEFAULT_COLOUR_M);
  if (help_parser(array_of_words_p, word_count) != 0) {
    printf("%sERROR:%s Help Funtion\n", ERROR_M, DEFAULT_COLOUR_M);
  }
  return 0;
}

// If graph mode called
// Check next argument
// Alter appropriate parameter
int graph_function(char **array_of_words_p[], int word_count, double *result) {
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Entered GRAPH function\n", DEBUG_M,
           DEFAULT_COLOUR_M);

  if (word_count == 2) {
    if (strcmp("on", (*array_of_words_p)[1]) == 0) {
      Set_Graph_Mode(1);
      Set_Formula_Mode(0);
      GraphInit();

      printf("%sSYSTEM_INFO:%s Graph ON\n", SYS_M, DEFAULT_COLOUR_M);
    } else if (strcmp("off", (*array_of_words_p)[1]) == 0) {
      Set_Graph_Mode(0);
      CalculatorInit();
      printf("%sSYSTEM_INFO:%s Graph OFF\n", SYS_M, DEFAULT_COLOUR_M);
    } else if (strcmp("rescale", (*array_of_words_p)[1]) == 0) {
      rescale_graph();
    } else if (strcmp("reset_scale", (*array_of_words_p)[1]) == 0) {
      reset_scale();
    } else if (strcmp("rad", (*array_of_words_p)[1]) == 0) {
      Set_Angle_Mode(1);
    } else if (strcmp("deg", (*array_of_words_p)[1]) == 0) {
      Set_Angle_Mode(0);
    } else if (strcmp("help", (*array_of_words_p)[1]) == 0) {
      graph_help();
    } else {
      printf("%sERROR:%s Unknown system command\n", ERROR_M, DEFAULT_COLOUR_M);
      return 1;
    }
  } else if (word_count > 2) {
    if (strcmp("scale", (*array_of_words_p)[1]) == 0) {
      if (word_count == 6) {
        double value_1 = 0;
        for (int i = 2; i < 6; i++) {
          if (sscanf((*array_of_words_p)[i], "%lf", &value_1) != 1) {
            printf("%sERROR:%s Found unknown argument\n", ERROR_M,
                   DEFAULT_COLOUR_M);
            return 1;
          } else {
            set_axis_scale(i, value_1);
          }
        }
      } else {
        printf(
            "%sERROR:%s Incorrect number of scale values:\n\tExpected: <x_min> "
            "<x_max> <y_min> <y_max>\n",
            ERROR_M, DEFAULT_COLOUR_M);
      }
    }
  } else {  // Less than 2 arguments
    printf("%sSYSTEM_INFO:%s Graph currently %s\n", SYS_M, DEFAULT_COLOUR_M,
           Get_System() == 0 ? "OFF" : "ON");
  }
  return 0;
}

// clang-format off
/***********************************************************************************************************************
*****************************************************String Parser******************************************************
***********************************************************************************************************************/
// clang-format on

// Takes input string, splits into words
int string_parser(char *inp, char **array_of_words_p[]) {
  const char delim = ' ';
  char curr_char;
  char prev_char = delim;
  int num_words = 0;
  int len_word = 0;
  int characters = 0;
  int i;

  // Iterate through string and count the numbr of words
  for (i = 0; i < strlen(inp); i++) {
    curr_char = inp[i];

    if (curr_char == '\0')
      return 0;  // No words in string
    else if (curr_char == delim &&
             prev_char == delim) {  // Multiple spaces in a row
    } else if (curr_char != delim && prev_char == delim) {  // Found new word
      num_words++;
      characters++;
    } else if (curr_char == delim && prev_char != delim) {
    } else {  // Currently in word, don't do anything
      characters++;
    }
    prev_char = curr_char;
  }

  // Allocate enough memory to store a pointer to each word
  *array_of_words_p = (char **)calloc(num_words, sizeof(char *));
  if (array_of_words_p == 0) {  // If malloc fails returns NULL ptr
    printf("%sERROR:%s Memory allocation failed\n", ERROR_M,
           DEFAULT_COLOUR_M);  // Log
    return -1;                 // Return Failed
  }
  // Set pointer to first word
  char *word_array = (char *)calloc((characters + num_words), sizeof(char));
  if (word_array == 0) {  // If malloc fails returns NULL ptr
    printf("%sERROR:%s Memory allocation failed\n", ERROR_M,
           DEFAULT_COLOUR_M);  // Log
    free(*array_of_words_p);
    return -1;  // Return Failed
  }

  // Reset variables
  prev_char = delim;
  curr_char = delim;
  num_words = 0;
  characters = 0;

  // Iterate over string again
  for (i = 0; i < strlen(inp); i++) {
    curr_char = inp[i];

    if (curr_char == '\0')
      return 0;  // No words in string
    else if (curr_char == delim &&
             prev_char == delim) {  // Multiple spaces in a row
    } else if (curr_char != delim && prev_char == delim) {  // Found new word
      characters++;
      num_words++;
      len_word = 1;
      (*array_of_words_p)[num_words - 1] =
          &word_array[characters - 1 + (num_words - 1)];
    } else if (curr_char == delim && prev_char != delim) {  // Found end of word
      // Copy inp into memory allocation
      strncpy(&word_array[characters - len_word + (num_words - 1)],
              (inp + (i - len_word)), len_word);
      len_word = 0;
    } else {  // Currently in word, don't do anything
      characters++;
      len_word++;
    }
    prev_char = curr_char;
  }
  if (len_word != 0) {
    // Copy inp into memory allocation
    strncpy(&word_array[characters - len_word + (num_words - 1)],
            (inp + (i - len_word)), len_word);
    len_word = 0;
  }
  return num_words;
}
/*
 * Author 	   : Mitchell Marotta C3258958
 * 				 Taylor Young C3206230
 * Date	  	   : 4 May 2018
 * Description : Q2
 *				 Calculator interface, used with the touchscreen
 */

/*
LCD_COLOR_BLUE          0x001F
LCD_COLOR_GREEN         0x07E0
LCD_COLOR_RED           0xF800
LCD_COLOR_CYAN          0x07FF
LCD_COLOR_MAGENTA       0xF81F
LCD_COLOR_YELLOW        0xFFE0
LCD_COLOR_LIGHTBLUE     0x841F
LCD_COLOR_LIGHTGREEN    0x87F0
LCD_COLOR_LIGHTRED      0xFC10
LCD_COLOR_LIGHTCYAN     0x87FF
LCD_COLOR_LIGHTMAGENTA  0xFC1F
LCD_COLOR_LIGHTYELLOW   0xFFF0
LCD_COLOR_DARKBLUE      0x0010
LCD_COLOR_DARKGREEN     0x0400
LCD_COLOR_DARKRED       0x8000
LCD_COLOR_DARKCYAN      0x0410
LCD_COLOR_DARKMAGENTA   0x8010
LCD_COLOR_DARKYELLOW    0x8400
LCD_COLOR_WHITE         0xFFFF
LCD_COLOR_LIGHTGRAY     0xD69A
LCD_COLOR_GRAY          0x8410
LCD_COLOR_DARKGRAY      0x4208
LCD_COLOR_BLACK         0x0000
LCD_COLOR_BROWN         0xA145
LCD_COLOR_ORANGE        0xFD20
*/

#include "Ass-02.h"

// clang-format off
/***********************************************************************************************************************
************************************************Calculator Initilisation************************************************
***********************************************************************************************************************/
// clang-format on

// Initilise the calculator and draw number pad
void DisplayInit() {
  // Initialize and turn on LCD and calibrate the touch panel
  BSP_LCD_Init();
  BSP_LCD_DisplayOn();
  BSP_TP_Init();

  // Clear screen
  BSP_LCD_Clear(LCD_COLOR_WHITE);
  BSP_LCD_SetFont(&Font12);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

  // Display title animation
  if (title_animation() != 0) {
    printf("%sERROR:%s Unable to draw animation", ERROR_M, DEFAULT_COLOUR_M);
  }
}

void CalculatorInit() {
  // Clear screen
  BSP_LCD_Clear(LCD_COLOR_WHITE);
  BSP_LCD_SetFont(&Font12);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

  // Set basic layout of calculator grid
  if (calculator_layout() != 0) {
    printf("%sERROR:%s Unable to draw layout", ERROR_M, DEFAULT_COLOUR_M);
  }

  // Initilise numpad symbol layout
  if (draw_numpad() != 0) {
    printf("%sERROR:%s Unable to draw numpad", ERROR_M, DEFAULT_COLOUR_M);
  }

  // If debug information is ON
  if (Get_Debug() == 1) {
    // Print grid cell spacings
    for (int tem = 0; tem < 25; tem++) {
      printf("%sDEBUG_INFO:%s pw %i, ph %i, cw %i, ch %i, pos %i, item %s\n",
             DEBUG_M, DEFAULT_COLOUR_M, Get_Area(tem, 0), Get_Area(tem, 1),
             Get_Area(tem, 2), Get_Area(tem, 3), Get_Area(tem, 4),
             Get_Item(Get_Area(tem, 4)));
    }
  }

  // Allocate memory for the input
  if (allocate_memory() != 0)
    printf("%sERROR:%s Could not allocate memory for EQUATION\n", ERROR_M,
           DEFAULT_COLOUR_M);

  // System information, memory for input
  if (Get_System() == 1)
    printf(
        "%sSYSTEM_INFO:%s Equation currently has %i memory free of total %i\n",
        SYS_M, DEFAULT_COLOUR_M, Get_Size() - Get_Pos(), Get_Size());
  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s Exiting init\n", DEBUG_M, DEFAULT_COLOUR_M);
}

// Draws basic grid pattern
int calculator_layout() {
  // Calculate grid spacing based off given width and height
  int num_Vline = 5;
  int num_Hline = 5;

  // LCD X and Y Size
  int display_height = BSP_LCD_GetYSize();
  int display_width = BSP_LCD_GetXSize();

  // Cell width and height for LCD
  int cell_width = display_width / num_Vline;
  int cell_height = display_height / num_Hline;

  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s cew %i, ceh %i\n", DEBUG_M, DEFAULT_COLOUR_M,
           cell_width, cell_height);

  // Populate grid_space struct
  int prev_width = display_width;
  int prev_height = display_height;
  int curr_height = prev_height;
  int curr_width = prev_width;
  int temp = 0;

  // Populate stuct with min max, x y coordinates for each button
  for (int i = 0; i < num_Hline; i++) {
    prev_height = curr_height;
    curr_height = curr_height - cell_height;
    curr_width = display_width;
    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO:%s pw %i, ph %i, cw %i, ch %i\n", DEBUG_M,
             DEFAULT_COLOUR_M, prev_width, prev_height, curr_width,
             curr_height);

    for (int j = 0; j < num_Vline; j++) {
      prev_width = curr_width;
      curr_width = prev_width - cell_width;

      // Store parameter calculated in correct position
      Set_Area(temp, 0, curr_width);
      Set_Area(temp, 1, prev_width);
      Set_Area(temp, 2, curr_height);
      Set_Area(temp, 3, prev_height);

      if (Get_Debug() == 1)
        printf("%sDEBUG_INFO:%s pw %i, ph %i, cw %i, ch %i\n", DEBUG_M,
               DEFAULT_COLOUR_M, prev_width, prev_height, curr_width,
               curr_height);

      temp = temp + 1;
    }
  }

  // Draw grid based on calculated positions
  uint16_t x_pos = 0;
  uint16_t y_pos = 0;
  uint16_t len = 0;

  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);

  // clang-format off
  /**************************************************Vertical Grid***************************************************/
  // clang-format on

  // y_pos is fixed for vertical lines
  y_pos = cell_height;
  // Length is the cell spacing for the horizontal lines * the number of
  // horizontal lines
  len = num_Hline * cell_height - cell_height;

  // For each vertical line calculate the x position and draw it
  for (int l = 0; l < num_Vline; l++) {
    if (l > 3) {
      y_pos = 0;
      len = num_Hline * cell_height;
    }
    x_pos = l * cell_width;
    BSP_LCD_DrawVLine(x_pos, y_pos, len);
    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO Vline:%s x %i, y %i, len %i\n", DEBUG_M,
             DEFAULT_COLOUR_M, x_pos, y_pos, len);
  }

  // clang-format off
  /*************************************************Horizontal Grid**************************************************/
  // clang-format on
  // x_pos is fixed for horizontal lines
  x_pos = display_width;
  // Length is the cell spacing for the vertical lines * the number of vertical
  // lines
  len = display_width;

  // For each horizontal line calculate the y position and draw it
  for (int l = 0; l < num_Hline; l++) {
    y_pos = l * cell_height;
    BSP_LCD_DrawHLine(0, y_pos, len);
    if (Get_Debug() == 1)
      printf("%sDEBUG_INFO Hline:%s x %i, y %i, len %i\n", DEBUG_M,
             DEFAULT_COLOUR_M, x_pos, y_pos, len);
  }
  return 0;
}

// Draw numpad layout
int draw_numpad() {
  // Draw numbers 0 - 9 in the relevant positions
  // Draw math symbols on first screen + - etc
  // Draw common symbols, AC del = etc

  // Loop through each item and draw it in the correct cell, record the item
  // number drawn
  for (int i = 0; i < 21; i++) {
    if (draw_item(i, 0, LCD_COLOR_BLACK, LCD_COLOR_WHITE) == 0) {
      Set_Area(i, 4, i - 0);

      if (Get_Debug() == 1)
        printf(
            "%sDEBUG_INFO Numpad:%s item %s, cell_number %i, grid_space %i\n",
            DEBUG_M, DEFAULT_COLOUR_M, Get_Item(i), i, Get_Area(i, 4));
    } else {
      printf("%sERROR:%s Could not draw item\n", ERROR_M, DEFAULT_COLOUR_M);
    }
  }
  return 0;
}

// Draw symbols layout
int draw_sym() {
  // Draw symbol screen (, ), % etc
  // Draw common symbols, AC del = etc

  // Loop through each item and draw it in the correct cell, record the item
  // number drawn
  for (int i = 0; i < 21; i++) {
    if (draw_item(i, 21, LCD_COLOR_BLACK, LCD_COLOR_WHITE) == 0) {
      Set_Area(i, 4, i + 21);
      if (Get_Debug() == 1)
        printf("%sDEBUG_INFO DRAW_SYM:%s item %s, cell_number %i, item %i\n",
               DEBUG_M, DEFAULT_COLOUR_M, Get_Item(i), i, Get_Area(i, 4));
    }
  }
  return 0;
}

// clang-format off
/*******************************************************************************************
*************************************Calculator Process*************************************
*******************************************************************************************/
// clang-format on

// Main calculator process function
void CalculatorProcess() {
  static int button_debounce = 0;
  static int off_debounce = 0;
  static int holding = 0;
  static int display_mode = 0;
  static int button_highlight = 0;
  static int touch_pos = 0;

  char output_ans[50];

  // getDisplayPoint(&display, Read_Ads7846(), &matrix );
  if (BSP_TP_GetDisplayPoint(&display) == 0) {
    button_debounce++;

    // If the button has successfully debounced and the user isn't holding the
    // button
    if (button_debounce >= 50 && holding == 0) {
      button_debounce = 0;
      off_debounce = 0;
      holding = 1;

      // Check that my char** isn't out of space
      if (Get_Pos() >= Get_Size()) {
        // Reallocate memory
        if (reallocate_memory() != 0)
          printf("%sERROR:%s Unable to reallocate enough memory\n", ERROR_M,
                 DEFAULT_COLOUR_M);
      }

      // Given grid struct and position touched, returns area touched
      touch_pos = get_touch_pos(display.x, display.y);
      if (Get_Debug() == 1)
        printf("%sDEBUG_INFO:%s touch_pos %i, position touched %i, %i\n",
               DEBUG_M, DEFAULT_COLOUR_M, touch_pos, display.x, display.y);

      if (touch_pos != 100) {
        if (Get_System() == 1)
          printf("%sSYSTEM_INFO:%s Selected %s\n", SYS_M, DEFAULT_COLOUR_M,
                 Get_Item(touch_pos));

        // Do something with selected item
        // If the selected item was delete
        // Delete the previous entry and redraw the equation
        if (strcmp(Get_Item(touch_pos), "DEL") == 0) {
          // Remove previous item from string
          if (Get_Pos() > 0) {
            if (Get_System() == 1)
              printf(
                  "%sSYSTEM_INFO:%s Formula Contains Before Deleting: %s, "
                  "equation.pos %i\n",
                  SYS_M, DEFAULT_COLOUR_M, Get_Formula(), Get_Pos());
            Increment_Pos(-1);
            Set_Input_Str(Get_Pos(), NULL);
            Set_Formula_c(Get_Pos(), NULL);
            if (Get_System() == 1)
              printf(
                  "%sSYSTEM_INFO:%s Formula Contains After Deleting: %s, "
                  "equation.pos %i\n",
                  SYS_M, DEFAULT_COLOUR_M, Get_Formula(), Get_Pos());
            if (draw_equation() != 0)
              printf("%sERROR:%s Could not draw equation\n", ERROR_M,
                     DEFAULT_COLOUR_M);
          } else {
            if (Get_Debug() == 1)
              printf("%sDEBUG_INFO:%s Whole string deleted\n", DEBUG_M,
                     DEFAULT_COLOUR_M);
          }
        }

        // If AC was selected
        // Clear the entire equation
        // Clear the screen
        else if (strcmp(Get_Item(touch_pos), "AC") == 0) {
          // Clear All items
          // Clear LCD
          if (clear_equation() != 0)
            printf("%sERROR:%s Could not clear Equation\n", ERROR_M,
                   DEFAULT_COLOUR_M);

          while (Get_Pos() > 0) {
            Increment_Pos(-1);
            Set_Input_Str(Get_Pos(), NULL);
          }
          if (Get_Pos() == 0) {
            if (Get_Debug() == 1)
              printf("%sDEBUG_INFO:%s Whole string deleted\n", DEBUG_M,
                     DEFAULT_COLOUR_M);
          }

        }

        // If symbol screen selected
        // Note that the display mode has changed
        // Redraw the items to be numpad|symbols
        else if ((strcmp(Get_Item(touch_pos), ">") == 0) ||
                 (strcmp(Get_Item(touch_pos), "<") == 0)) {
          // Switch display mode
          display_mode++;
          if (display_mode > 1) {
            display_mode = 0;
          } else if (display_mode < 0) {
            display_mode = 1;
          }
          if (display_mode == 0) {
            if (draw_numpad() != 0) {
              printf("%sERROR:%s Unable to draw sym", ERROR_M,
                     DEFAULT_COLOUR_M);
            }
          } else if (display_mode == 1) {
            if (draw_sym() != 0) {
              printf("%sERROR:%s Unable to draw numpad", ERROR_M,
                     DEFAULT_COLOUR_M);
            }
          }
        }

        // If the equals was selected
        else if (strcmp(Get_Item(touch_pos), "=") == 0 && Get_Pos() > 0) {
          // Equate equation
          // Call function return answer
          // prev_ans = parseFormula(input);
          // Save answer
          if (Get_System() == 1) {
            for (int num_str = 0; num_str < Get_Pos(); num_str++) {
              printf(
                  "%sSYSTEM_INFO:%s %i String of %i stings: string %s, length "
                  "%i\n",
                  SYS_M, DEFAULT_COLOUR_M, num_str + 1, Get_Pos(),
                  Get_Input_Str(num_str), strlen(Get_Input_Str(num_str)));
            }
          }

          if (Get_System() == 1)
            printf(
                "%sSYSTEM_INFO:%s Formula Contains Before Parsing: %s, "
                "equation.pos %i\n",
                SYS_M, DEFAULT_COLOUR_M, Get_Formula(), Get_Pos());

          if (parseFormula() == 0) {
            Set_Prev_ans(Get_Result());
            if (Get_System() == 1)
              printf("%sSYSTEM_INFO:%s Result %g\n", SYS_M, DEFAULT_COLOUR_M,
                     Get_Result());

            // Print answer to screen
            if (clear_equation() != 0)
              printf("%sERROR:%s Could not clear Equation\n", ERROR_M,
                     DEFAULT_COLOUR_M);
            if (draw_result(0) != 0)
              printf("%sERROR:%s Could not print result\n", ERROR_M,
                     DEFAULT_COLOUR_M);

          } else {
            Set_Prev_ans(0);
            // Print answer to screen
            if (clear_equation() != 0)
              printf("%sERROR:%s Could not clear Equation\n", ERROR_M,
                     DEFAULT_COLOUR_M);
            if (draw_result(1) != 0)
              printf("%sERROR:%s Could not print result\n", ERROR_M,
                     DEFAULT_COLOUR_M);
          }

          // Clear formula
          for (int j = 0; j < Get_Pos(); j++) {
            Free_Input_Str(j);
          }

          while (Get_Pos() > 0) {
            Increment_Pos(-1);
            Set_Input_Str(Get_Pos(), NULL);
          }
          if (Get_Pos() == 0) {
            if (Get_Debug() == 1)
              printf("%sDEBUG_INFO:%s Whole string deleted\n", DEBUG_M,
                     DEFAULT_COLOUR_M);
          }

          Set_Pos(0);

          if (Get_System() == 1)
            printf("%sSYSTEM_INFO:%s Previous answer saved as %lf\n", SYS_M,
                   DEFAULT_COLOUR_M, Get_Prev_ans());

          Set_First_Time(1);
        }

        // If previous answer selected, append the previous answer to the
        // current equation
        else if (strcmp(Get_Item(touch_pos), "ANS") == 0) {
          // Insert previous answer into equation as number
          if (Get_Debug() == 1)
            printf("%sDEBUG_INFO:%s Writing String %s\n", DEBUG_M,
                   DEFAULT_COLOUR_M, Get_Item(touch_pos));
          snprintf(output_ans, 50, "%f", Get_Prev_ans());

          if (Input_append(output_ans) != 0)
            printf("%sERROR:%s Could not append string\n", ERROR_M,
                   DEFAULT_COLOUR_M);
        }

        // Else the calculation solver should be able to handle the input, jsut
        // append it to the string
        else {
          // Append symbol(s) to string
          if (Get_Debug() == 1)
            printf("%sDEBUG_INFO:%s Writing String %s\n", DEBUG_M,
                   DEFAULT_COLOUR_M, Get_Item(touch_pos));

          if (Input_append(Get_Item(touch_pos)) != 0)
            printf("%sERROR:%s Could not append string\n", ERROR_M,
                   DEFAULT_COLOUR_M);
        }

        // A button was pressed, highlight the cell of the button
        if (button_highlight == 0) {
          if (LCD_Cell_Highlight(button_highlight, touch_pos, display_mode) !=
              0) {
            printf("%sERROR:%s Could not highlight cell\n", ERROR_M,
                   DEFAULT_COLOUR_M);
          }
          button_highlight = 1;
        }
      }
      if (Get_Debug() == 1) {
        for (int i = 0; i < Get_Pos(); i++) {
          printf("%sDEBUG_INFO:%s Equation.Input[%i] Contains %s  length %i\n",
                 DEBUG_M, DEFAULT_COLOUR_M, i, Get_Input_Str(i),
                 strlen(Get_Input_Str(i)));
        }
      }
      if (Get_Debug() == 1)
        printf(
            "%sDEBUG_INFO:%s Equation currently has %i memory free of total "
            "%i\n",
            DEBUG_M, DEFAULT_COLOUR_M, Get_Size() - Get_Pos(), Get_Size());
    }
    // If the user is holding the button down, don't perform the action
    else if (button_debounce >= 50 && holding == 1) {
      button_debounce = 0;
      off_debounce = 0;
    }
  }

  // No button pressed, debounce this
  else {
    off_debounce++;
    // User is definately not pressing a button, reset the holding flag
    if (off_debounce > 100) {
      holding = 0;
      button_debounce = 0;
      off_debounce = 0;
      if (button_highlight == 1) {
        if (LCD_Cell_Highlight(button_highlight, touch_pos, display_mode) !=
            0) {
          printf("%sERROR:%s Could not highlight cell\n", ERROR_M,
                 DEFAULT_COLOUR_M);
        }
        button_highlight = 0;
        if (Get_System() == 1)
          printf("%sSYSTEM_INFO:%s Cleared Highlight Now\n", SYS_M,
                 DEFAULT_COLOUR_M);
      }
    }
  }
}

// Colours a specific cell a given colour
int LCD_Cell_Colour(int x_min, int x_max, int y_min, int y_max, int text_colour,
                    int cell_colour) {
  BSP_LCD_SetTextColor(cell_colour);
  /* Draw a rectangle with background color */
  BSP_LCD_FillRect((x_min + 1), (y_min + 1), (x_max - x_min - 2),
                   (y_max - y_min - 2));
  BSP_LCD_SetTextColor(text_colour);

  return 0;
}

// TODO Doesn't seem to work at all. Probably just remove for now to simplify
// Highlight a specific cell and redraw the symbol
int LCD_Cell_Highlight(int status, int item_number, int display_mode) {
  // Status : on|off
  // Item_number : 0 to 41
  // display_mode : number|symbol

  // Draw coloured cell
  // Redraw symbol
  int offset = display_mode == 0 ? 0 : 21;
  int cell_number = item_number - offset;

  if (cell_number < 0 || cell_number > 20) {
    printf("%sERROR:%s Cell_number out of range %i, offset %i\n", ERROR_M,
           DEFAULT_COLOUR_M, cell_number, offset);
  } else {
    int x_min = Get_Area(cell_number, 0);
    int x_max = Get_Area(cell_number, 1);
    int y_min = Get_Area(cell_number, 2);
    int y_max = Get_Area(cell_number, 3);

    printf("%sDEBUG_INFO %sLCD_HIGHLIGHT: cell_number %i, offset %i\n", DEBUG_M,
           DEFAULT_COLOUR_M, cell_number, (display_mode == 0 ? 0 : 21));
    printf(
        "%sDEBUG_INFO %sLCD_HIGHLIGHT: x_min %i, x_max %i, y_min %i, y_max "
        "%i\n",
        DEBUG_M, DEFAULT_COLOUR_M, x_min, x_max, y_min, y_max);

    // Highlight is currently on
    if (status == 1) {
      // Set highlight to off
      HAL_GPIO_TogglePin(GPIOD, LD4_Pin);

      if (LCD_Cell_Colour(x_min, x_max, y_min, y_max, LCD_COLOR_BLACK,
                          LCD_COLOR_WHITE) != 0) {
        printf("%sERROR:%s Could not clear cell\n", ERROR_M, DEFAULT_COLOUR_M);
      }
      if (draw_item(cell_number, offset, LCD_COLOR_BLACK, LCD_COLOR_WHITE) != 0)
        printf("%sERROR:%s Could not redraw symbol\n", ERROR_M,
               DEFAULT_COLOUR_M);

      return 0;
    }

    // Highlight is currently off
    else if (status == 0) {
      // Set highlight to on
      HAL_GPIO_TogglePin(GPIOD, LD4_Pin);

      if (LCD_Cell_Colour(x_min, x_max, y_min, y_max, LCD_COLOR_BLACK,
                          LCD_COLOR_YELLOW) != 0) {
        printf("%sERROR:%s Could not clear cell\n", ERROR_M, DEFAULT_COLOUR_M);
      }
      if (draw_item(cell_number, offset, LCD_COLOR_BLACK, LCD_COLOR_YELLOW) !=
          0)
        printf("%sERROR:%s Could not redraw symbol\n", ERROR_M,
               DEFAULT_COLOUR_M);
      return 0;
    } else {
      printf("%sERROR:%s Unknown status %i, Cell_number %i, offset %i\n",
             ERROR_M, DEFAULT_COLOUR_M, status, cell_number, offset);
    }
  }
  return 1;
}

// Draw the result of the equation on the screen
int draw_result(int status) {
  // If status is 0 print result
  // else print syntax %sERROR%s
  // Draws specific character passed into function
  int x_min = Get_Area(24, 0);
  int x_max = Get_Area(21, 1);
  int y_min = Get_Area(24, 2);
  int y_max = Get_Area(24, 3);

  if (LCD_Cell_Colour(x_min, x_max, y_min, y_max, LCD_COLOR_BLACK,
                      LCD_COLOR_WHITE) != 0) {
    printf("%sERROR:%s Could not clear cell\n", ERROR_M, DEFAULT_COLOUR_M);
  }

  // Find center of cell given
  int x_pos = ((x_max - x_min) / 2.0) + x_min;
  int y_pos = ((y_max - y_min) / 2.0) + y_min;

  if (Get_Debug() == 1)
    printf(
        "%sDEBUG_INFO:%s x_min %i, x_max %i, y_min %i, y_max %i, x_pos %i, "
        "y_pos %i\n",
        DEBUG_M, DEFAULT_COLOUR_M, x_min, x_max, y_min, y_max, x_pos, y_pos);

  char result_str[13];
  if (status == 0)
    snprintf(result_str, 10, "%g", Get_Result());
  else
    strcpy(result_str, "Syntax Error");

  if (clear_equation() != 0)
    printf("%sERROR:%s Could not clear Equation\n", ERROR_M, DEFAULT_COLOUR_M);

  if (Get_Debug() == 1)
    printf("%sDEBUG_INFO:%s result_str %s\n", DEBUG_M, DEFAULT_COLOUR_M,
           result_str);

  BSP_LCD_SetFont(&Font16);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
  BSP_LCD_DisplayStringAt(x_min + 5, y_pos, (uint8_t*)result_str, LEFT_MODE);

  return 0;
}

// Clear the equation from the screen
int clear_equation() {
  // Draws specific character passed into function
  int x_min = Get_Area(24, 0);
  int x_max = Get_Area(21, 1);
  int y_min = Get_Area(24, 2);
  int y_max = Get_Area(24, 3);
  printf(
      "%sDEBUG_INFO Clearing Screen:%s x_min %i, x_max %i, y_min %i, y_max "
      "%i\n",
      DEBUG_M, DEFAULT_COLOUR_M, x_min, x_max, y_min, y_max);

  if (LCD_Cell_Colour(x_min, x_max, y_min, y_max, LCD_COLOR_BLACK,
                      LCD_COLOR_WHITE) != 0) {
    printf("%sERROR:%s Could not clear cell\n", ERROR_M, DEFAULT_COLOUR_M);
  }

  return 0;
}
#include "Ass-02-Screen.h"
#include "Ass-02.h"

void Screen_Init(void) {
  static char *item[42] = {
      "=",  "+",     "ANS",   ".",     "0",    ">",   "-",     "3",    "2",
      "1",  "<",     "/",     "6",     "5",    "4",   "AC",    "x",    "9",
      "8",  "7",     "DEL",   "=",     "(",    "ANS", "sqrt(", "^",    ">",
      ")",  "atan(", "acos(", "asin(", "<",    "pi",  "tan(",  "cos(", "sin(",
      "AC", "",      "log(",  "ln(",   "exp(", "DEL"};
  // Store that array of strings in the struct
  grid_space_p.items = item;
}

// Return the value x_min x_max y_min y_max of the given button
// Pos1 button number
// Pos2 parameter x_min x_max y_min y_max
int Get_Area(int pos1, int pos2) { return (grid_space_p.Area[pos1][pos2]); }

// Return the item number of the button given
char *Get_Item(int Item_Value) { return (grid_space_p.items[Item_Value]); }

// Set the value of the given button and given parameter to value
// Pos1 button number
// Pos2 parameter x_min x_max y_min y_max
void Set_Area(int pos1, int pos2, int value) {
  grid_space_p.Area[pos1][pos2] = value;
}

// Set the button item to Value
void Set_Item(int pos, int Item_number) {
  grid_space_p.items[pos] = Item_number;
}

// Return the item touched on the screen
int get_touch_pos(int display_x, int display_y) {
  for (int i = 0; i < 21; i++) {
    if ((display_x >= grid_space_p.Area[i][0]) &&
        (display_x <= grid_space_p.Area[i][1]) &&
        (display_y >= grid_space_p.Area[i][2]) &&
        (display_y <= grid_space_p.Area[i][3])) {
      return (grid_space_p.Area[i][4]);
    }
  }
  // Dummy variable if out of range
  return 100;
}

// Draw specific item in a specific cell
int draw_item(int cell_number, int offset, int text_colour, int cell_colour) {
  // Cell_number : 0 to 21
  // Offset : 0 or 21, depending on symbol or number screen

  // Draws specific character passed into function
  int x_min = grid_space_p.Area[cell_number][0];
  int x_max = grid_space_p.Area[cell_number][1];
  int y_min = grid_space_p.Area[cell_number][2];
  int y_max = grid_space_p.Area[cell_number][3];

  if (LCD_Cell_Colour(x_min, x_max, y_min, y_max, text_colour, cell_colour) !=
      0) {
    printf("%sERROR:%s Could not clear cell\n", ERROR_M, DEFAULT_COLOUR_M);
  }
  // Find center of cell given
  int x_pos = ((x_max - x_min) / 2.0) + x_min;
  int y_pos = ((y_max - y_min) / 2.0) + y_min;

  BSP_LCD_SetFont(&Font16);
  BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
  BSP_LCD_DisplayStringAt(x_pos, y_pos,
                          (uint8_t *)grid_space_p.items[cell_number + offset],
                          CENTER_MODE);

  return 0;
}
/*
 * Author      : Mitchell Marotta C3258958
 *               Taylor Young C3206230
 * Date        : 4 May 2018
 * Description : Initilise some variables
 *               Initilise some arrays
 */

#include "Ass-02.h"

void Ass_02_Main(void) {
#ifdef STM32F407xx
  uint16_t i = 0;
#endif
  Debug_Init();
  Equation_Init();
  Screen_Init();

  CommandLineParserInit();
  
#ifdef STM32F407xx
  // Initilise array of strings for the buttons in Q2
  DisplayInit();

  if (Get_Graph_Mode() == 0) {
    CalculatorInit();
  } else if (Get_Graph_Mode() == 1) {
    GraphInit();
  }
#endif

  // Loop indefinitely
  while (1) {
    CommandLineParserProcess();
#ifdef STM32F407xx
    if (Get_Graph_Mode() == 0) {
      CalculatorProcess();
    }
#endif

#ifdef STM32F407xx
    if (i++ > 10000) {
      HAL_GPIO_TogglePin(GPIOD, LD3_Pin);  // Toggle LED3
      i = 0;
    }
#endif
  }
}
#ifndef ASS_02_DEBUG_H_
#define ASS_02_DEBUG_H_

#include "Ass-02.h"

typedef struct {
  int debug;
  int system;
  int formula_mode;
  int first_time;
  int graph_mode;
  int angle_mode;
} sys_t;
sys_t info;

extern void Debug_Init(void);
extern int Get_Debug(void);
extern int Get_System(void);
extern int Get_Formula_Mode(void);
extern int Get_First_Time(void);
extern int Get_Graph_Mode(void);
extern void Set_Debug(int Value);
extern void Set_System(int Value);
extern void Set_Formula_Mode(int Value);
extern void Set_First_Time(int Value);
extern void Set_Graph_Mode(int Value);

#endif /* ASS_02_DEBUG_H_ */
#ifndef ASS_02_EQUATION_H_
#define ASS_02_EQUATION_H_

#include "Ass-02.h"

typedef struct {
  int size;
  char **input;
  int pos;
} str_mem;
str_mem equation;

typedef struct {
  char *formula;
  int pos;
  double result;
  double prev_ans;
} result_mem;
result_mem output;

extern void Equation_Init(void);
extern int Get_Size(void);
extern char **Get_Input(void);
extern char *Get_Input_Str(int position);
extern int Get_Pos(void);
extern void Set_Size(int Value);
extern void Set_Input(char **Value);
extern void Set_Input_Str(int position, char *Value);
extern void Set_Pos(int Value);
extern void Free_Input_Str(int position);
extern char Get_Formula_c(void);
extern char Get_Formula_c_pos(int position);
extern char *Get_Formula(void);
extern double Get_Result(void);
extern double Get_Prev_ans(void);
extern void Set_Formula(char *Value);
extern void Set_Formula_c(int position, char Value);
extern void Set_Result(double Value);
extern void Set_Prev_ans(double Value);
extern int Increment_Pos(int Direction);
extern void Reset_Formula_pos(void);

#endif /* ASS_02_EQUATION_H_ */
#ifndef ASS_02_GRAPH_H_
#define ASS_02_GRAPH_H_

#include "Ass-02.h"

#define MAX_AXIS_NUM 5
#define CHAR_HEIGHT 5
#define DEFAULT_X_MIN -10
#define DEFAULT_X_MAX 10
#define DEFAULT_Y_MIN -10
#define DEFAULT_Y_MAX 10
#define DEFAULT_DELTA 0.01

typedef struct {
  char *formula;
  int pos;
  double result;
  double prev_ans;
  double x_min;
  double x_max;
  double y_min;
  double y_max;
  double delta;
  double increment;
} formula;
formula graph;

typedef struct {
  int x_axis_min;
  int x_axis_max;
  int y_axis_min;
  int y_axis_max;

} layout_t;
layout_t layout;

extern double Get_Graph_Increment(void);
extern int Get_Graph_Mode(void);
extern void GraphInit(void);
extern void GraphProcess(void);
extern int Graph_StringProcess(char *command_line, int i);
extern int graph_layout(void);

extern double Map_X_Display(double Input);
extern double Map_Y_Display(double Input);

extern int draw_axisnum(void);
extern void graph_help(void);
extern void set_axis_scale(int i, double Value);
extern double Get_axis_scale(int Value);
extern void Set_Graph_Increment(double Value);
extern void reset_scale(void);
extern void rescale_graph(void);

#endif /* ASS_02_GRAPH_H_ */
#ifndef ASS_02_SCREEN_H_
#define ASS_02_SCREEN_H_

typedef struct {
  int Area[25][5];
  char **items;
} grid_struct;
grid_struct grid_space_p;

extern void Screen_Init(void);
extern int Get_Area(int pos1, int pos2);
extern char *Get_Item(int Item_Value);
extern void Set_Area(int pos1, int pos2, int value);
extern void Set_Item(int pos, int Item_number);

#endif /* ASS_02_SCREEN_H_ */
/*
 * Author 	   : Mitchell Marotta C3258958
 * 				 Taylor Young C3206230
 * Date	  	   : 4 May 2018
 * Description : Assignment 2 header file
 */

#ifndef ASS_02_H_
#define ASS_02_H_

// Standard includes
#ifdef STM32F407xx
#include "openx07v_c_lcd.h"
#include "stm32f4xx_hal.h"
#include "touch_panel.h"

#else
#include <windows.h>
#endif

#define KNRM "\e[0m"
#define KRED "\e[31m"  //"\x1B[31m"
#define KGRN "\e[32m"
#define KYEL "\e[33m"
#define KBLU "\e[34m"
#define KMAG "\e[35m"
#define KCYN "\e[36m"
#define KWHT "\e[37m"

#define CLEAR_M "\014"
#define RESET_M "\033[3J"

#include "Ass-02-Debug.h"
#include "Ass-02-Equation.h"
#include "Ass-02-Screen.h"
#include "Ass-02-Graph.h"

#include <malloc.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#define MemExpand 10

#define DEFAULT_COLOUR_M KNRM
#define DEBUG_M KYEL
#define SYS_M KMAG
#define ERROR_M KRED

#define HELP_M "%-25.25s\t%-35.35s"
#define DEBUG_P { printf("File %s, function %s, line %i\n", __FILE__, __FUNCTION__, __LINE__); }

#define LCD_COLOR_BLUE          0x001F
#define LCD_COLOR_GREEN         0x07E0
#define LCD_COLOR_RED           0xF800
#define LCD_COLOR_CYAN          0x07FF
#define LCD_COLOR_MAGENTA       0xF81F
#define LCD_COLOR_YELLOW        0xFFE0
#define LCD_COLOR_LIGHTBLUE     0x841F
#define LCD_COLOR_LIGHTGREEN    0x87F0
#define LCD_COLOR_LIGHTRED      0xFC10
#define LCD_COLOR_LIGHTCYAN     0x87FF
#define LCD_COLOR_LIGHTMAGENTA  0xFC1F
#define LCD_COLOR_LIGHTYELLOW   0xFFF0
#define LCD_COLOR_DARKBLUE      0x0010
#define LCD_COLOR_DARKGREEN     0x0400
#define LCD_COLOR_DARKRED       0x8000
#define LCD_COLOR_DARKCYAN      0x0410
#define LCD_COLOR_DARKMAGENTA   0x8010
#define LCD_COLOR_DARKYELLOW    0x8400
#define LCD_COLOR_WHITE         0xFFFF
#define LCD_COLOR_LIGHTGRAY     0xD69A
#define LCD_COLOR_GRAY          0x8410
#define LCD_COLOR_DARKGRAY      0x4208
#define LCD_COLOR_BLACK         0x0000
#define LCD_COLOR_BROWN         0xA145
#define LCD_COLOR_ORANGE        0xFD20

// Assignment main
extern void Ass_02_Main(void);

typedef struct {
  int BGColour;
} animation_s;

// Question 1
typedef struct {
  char *NameString;                             // Operation string
  int (*Function_p)(char **array_of_words_p[],  // Array pointer
                    int word_count,             // Function pointer
                    double *result);            // Result Pointer
  char *HelpString;                             // Help information
  char *DescriptionString;                      // Description
} command_s;

// Question 1
extern void CommandLineParserInit(void);
extern void CommandLineParserProcess(void);

extern int StringProcess(char *command_line, int i);
extern int string_parser(char *inp, char **array_of_words_p[]);
extern int help_parser(char **array_of_words_p[], int word_count);
extern int command_parser(char **array_of_words_p[], int word_count,
                          double *prev_ans);

extern int add_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int sub_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int mul_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int div_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int sin_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int cos_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int tan_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int asin_function(char **array_of_words_p[], int word_count,
                         double *result);
extern int acos_function(char **array_of_words_p[], int word_count,
                         double *result);
extern int atan_function(char **array_of_words_p[], int word_count,
                         double *result);
extern int pow_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int sqrt_function(char **array_of_words_p[], int word_count,
                         double *result);
extern int ln_function(char **array_of_words_p[], int word_count,
                       double *result);
extern int log_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int exp_function(char **array_of_words_p[], int word_count,
                        double *result);
extern int formula_function(char **array_of_words_p[], int word_count,
                            double *result);
extern int debug_function(char **array_of_words_p[], int word_count,
                          double *result);
extern int system_function(char **array_of_words_p[], int word_count,
                           double *result);
extern int clear_function(char **array_of_words_p[], int word_count,
                          double *result);
extern int reset_function(char **array_of_words_p[], int word_count,
                          double *result);
extern int help_function(char **array_of_words_p[], int word_count,
                         double *result);
extern int graph_function(char **array_of_words_p[], int word_count, double *result);

// Question 2
extern void CalculatorInit(void);
extern int title_animation(void);
extern int calculator_layout(void);
extern int draw_numpad(void);
extern int draw_sym(void);
extern int draw_item(int cell_number, int offset, int text_colour,
                     int cell_colour);
extern int LCD_Cell_Colour(int x_min, int x_max, int y_min, int y_max,
                           int text_colour, int cell_colour);

extern void CalculatorProcess(void);
extern int get_touch_pos(int display_x, int display_y);
extern int Input_append(char *item);
extern int LCD_Cell_Highlight(int status, int cell_number, int offset);
extern int allocate_memory(void);
extern int reallocate_memory(void);
extern int clear_equation(void);
extern int draw_equation(void);
extern int draw_result(int status);

// Recursive decent parser
extern double parseFormula(void);
extern double parseSub(void);
extern double parseSum(void);
extern double parsePro(void);
extern double parseDiv(void);
extern double parseFactor(void);
extern double parseNumber(void);
extern double parsePow(void);

// Library functions
#ifdef STM32F407xx
extern uint8_t BSP_TP_Init(void);
extern uint8_t BSP_TP_GetDisplayPoint(Coordinate *pDisplay);
#endif




#endif /* ASS_02_H_ */
